(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{457:function(t,a,e){"use strict";e.r(a);var s=e(65),v=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("超文本传输协议(http)是一个用以传输超媒体文档(如图片、html、css、js、视频等)的应用层协议，他是为web浏览器与web服务器之前的通讯而设计的")]),t._v(" "),e("p",[t._v("客户端与服务端通过交换各自的消息进行交互；由像浏览器这样的客户端发出的消息叫做request，被服务端响应的消息叫做response")]),t._v(" "),e("p",[t._v("http是应用层协议，通过TCP或TLS(加密TCP)链接来发送")]),t._v(" "),e("h2",{attrs:{id:"http组件系统"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http组件系统"}},[t._v("#")]),t._v(" http组件系统")]),t._v(" "),e("p",[t._v("http是一个client-server协议，每一个发送到服务器的请求（request），都会被服务器处理并返回一个消息（response）。在这个请求与响应的中间，还有许多proxy代理实体(如网关、缓存等)；这些构成http组件系统的细节被隐藏")]),t._v(" "),e("h3",{attrs:{id:"client"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#client"}},[t._v("#")]),t._v(" client")]),t._v(" "),e("p",[t._v("也就是我们在Request Headers中看到的use-agent，实际的请求发起者，一般由浏览器扮演(所以我们在use-agent里面看到的是浏览器信息)")]),t._v(" "),e("p",[t._v("要展现一个网页，浏览器首先发送一个请求来获取页面HTML文档，再解析文档中的资源信息发送其他请求获取如脚本、css、图片、视频来进行页面布局渲染；然后，浏览器再将这些内容整合，渲染成网页。同时，浏览器会执行获取的脚本，脚本内也可以发起请求获取更多的资源，并更新网页")]),t._v(" "),e("h3",{attrs:{id:"server"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#server"}},[t._v("#")]),t._v(" server")]),t._v(" "),e("p",[t._v("web server服务端，充当通讯过程响应角色，由它来服务并提供客户端所请求的文档。server只是虚拟意义上的一个机器：它可以是共享负载（负载均衡）的一组服务器组成的计算机集群；也可以是一种复杂的软件，通过向其他计算机（如缓存，数据库，电子商务服务器...）发起请求获取资源")]),t._v(" "),e("h3",{attrs:{id:"proxies代理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#proxies代理"}},[t._v("#")]),t._v(" proxies代理")]),t._v(" "),e("p",[t._v("在浏览器和服务器之前，有许多计算机和其他设备转发了http消息，它们大多数出现在传输层、网络层、物理层上，代理主要的作用有：")]),t._v(" "),e("p",[t._v("1、缓存（如浏览器缓存）")]),t._v(" "),e("p",[t._v("2、过滤（像反病毒扫描、家长控制）")]),t._v(" "),e("p",[t._v("3、负载均衡（让多个服务器服务不同请求）")]),t._v(" "),e("p",[t._v("4、认证（对不同资源进行权限管理）")]),t._v(" "),e("p",[t._v("5、日志记录（存储历史信息）")]),t._v(" "),e("h2",{attrs:{id:"http特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http特性"}},[t._v("#")]),t._v(" http特性")]),t._v(" "),e("h3",{attrs:{id:"简单"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简单"}},[t._v("#")]),t._v(" 简单")]),t._v(" "),e("p",[t._v("虽然下一代的http协议将http消息封装到了帧(frames)中，但大体上还是简单易读的")]),t._v(" "),e("h3",{attrs:{id:"可拓展性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#可拓展性"}},[t._v("#")]),t._v(" 可拓展性")]),t._v(" "),e("p",[t._v("http Headers的出现，让协议拓展变得非常容易，只要服务端和客户端就新的headers达成语义一致，新功能就能轻松加入")]),t._v(" "),e("h3",{attrs:{id:"无状态-有会话"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#无状态-有会话"}},[t._v("#")]),t._v(" 无状态，有会话")]),t._v(" "),e("p",[t._v("http是无状态的，在同一连接中，两个执行成功的请求之间没有关系。这就带来一个问题，如在电商网站，用户将某个物品加入购物车，切换页面后又再次添加了商品；这两次添加商品的请求之间没有关系，浏览器无法知道用户最终选择了哪些商品")]),t._v(" "),e("p",[t._v("为了解决此类问题，http进行头部拓展，通过http Cookies来解决；把Cookies加入头部中，创建一个会话让请求都能共享相同的上下文信息，达成多次请求状态共享")]),t._v(" "),e("p",[t._v("本质上，http是无状态的，但使用Cookies可以创建有状态的会话")]),t._v(" "),e("h3",{attrs:{id:"http连接"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http连接"}},[t._v("#")]),t._v(" http连接")]),t._v(" "),e("p",[t._v("http连接由传输层控制，但http并不需要底层的协议是面向连接的，只需要它可靠，并不丢失消息(至少返回错误)即可。在互联网中最常用的两个传输协议中：TCP协议是可靠的，UDP不是；因此http依赖于面向连接的TCP进行消息传递，但对http来说，连接并不是必须的（http升级）")]),t._v(" "),e("p",[t._v("在客户端（通常指浏览器）与服务器能够交互（客户端发起请求，服务器返回响应）之前，必须在这两者间建立一个 TCP 链接，打开一个 TCP 连接需要多次往返交换消息（因此耗时）。http/1.0 默认为每一对 http 请求/响应都打开一个单独的 TCP 连接。当需要连续发起多个请求时，这种模式比多个请求共享同一个 TCP 链接更低效。")]),t._v(" "),e("p",[t._v("为了减轻这些缺陷，http/1.1引入了流水线（被证明难以实现）和持久连接的概念：底层的TCP连接可以通过Connection头部来被部分控制。")]),t._v(" "),e("p",[t._v("http/2则发展得更远，通过在一个连接复用消息的方式来让这个连接始终保持为暖连接。")]),t._v(" "),e("p",[t._v("为了更好的适合http，设计一种更好传输协议的进程一直在进行。Google就研发了一种以UDP为基础，能提供更可靠更高效的传输协议QUIC。")]),t._v(" "),e("h3",{attrs:{id:"tcp"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp"}},[t._v("#")]),t._v(" TCP")]),t._v(" "),e("h3",{attrs:{id:"udp"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#udp"}},[t._v("#")]),t._v(" UDP")]),t._v(" "),e("h3",{attrs:{id:"quic"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#quic"}},[t._v("#")]),t._v(" QUIC")]),t._v(" "),e("h2",{attrs:{id:"http控制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http控制"}},[t._v("#")]),t._v(" http控制")]),t._v(" "),e("p",[t._v("http良好的拓展性使得越来越多的web功能归期控制。缓存和认证很早就由http控制，而同源同域的限制则是2010")]),t._v(" "),e("h3",{attrs:{id:"缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[t._v("#")]),t._v(" 缓存")]),t._v(" "),e("p",[t._v("文档如果缓存通过http控制，服务端能告诉代理和客户端哪些文件需要被缓存，被缓存多久；而客户端也能命令中间的缓存代理忽略存储的文档")]),t._v(" "),e("h3",{attrs:{id:"同源限制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#同源限制"}},[t._v("#")]),t._v(" 同源限制")]),t._v(" "),e("p",[t._v("为了防止网络监听等安全性问题，浏览器强制对web网站做了限制，只有来自相同源的网页才能获取网站的全部信息。这样的限制有时反而成了负担，http通过修改头部来开发这样的限制，因此web文档可以由不同域下的内容组成")]),t._v(" "),e("h3",{attrs:{id:"认证"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#认证"}},[t._v("#")]),t._v(" 认证")]),t._v(" "),e("p",[t._v("一些页面能够被保护起来，仅让特定的用户进行访问。基础的认证功能可以直接通过http提供，使用http cookies来设置指定的会话")]),t._v(" "),e("h3",{attrs:{id:"代理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代理"}},[t._v("#")]),t._v(" 代理")]),t._v(" "),e("p",[t._v("通常情况下，服务器、客户端都是处于内网的，对外网隐藏真实IP地址。因此http请求就要通过代理来解决这个网络障碍")]),t._v(" "),e("h3",{attrs:{id:"会话"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#会话"}},[t._v("#")]),t._v(" 会话")]),t._v(" "),e("p",[t._v("http cookies允许你用一个服务端的状态发起请求，这就创建了会话，这使得网站能轻松的为用户定制展示的内容")]),t._v(" "),e("h2",{attrs:{id:"http流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http流"}},[t._v("#")]),t._v(" http流")]),t._v(" "),e("p",[t._v("当客户端和服务端(指最终服务器或中间代理)进行消息交互时，主要有以下几步")]),t._v(" "),e("p",[t._v("1、打开一个TCP连接：TCP连接被用来发生消息以及接受对应的响应消息。客户端可能打开一个新的TCP连接，也可能复用一个已经打开的TCP连接")]),t._v(" "),e("p",[t._v("2、客户端发送HTTP报文")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("GET / HTTP/1.1\nHost: developer.mozilla.org\nAccept-Language: fr\n")])])]),e("p",[t._v("3、读取服务端返回的报文信息")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('HTTP/1.1 200 OK\nDate: Sat, 09 Oct 2010 14:28:02 GMT\nServer: Apache\nLast-Modified: Tue, 01 Dec 2009 20:18:22 GMT\nETag: "51142bc1-7449-479b075b2891b"\nAccept-Ranges: bytes\nContent-Length: 29769\nContent-Type: text/html\n\n<!DOCTYPE html... (here comes the 29769 bytes of the requested web page)\n')])])]),e("p",[t._v("4、关闭连接或为后续连接重用连接")]),t._v(" "),e("p",[t._v("早期的设计思路想通过流水线形式，让后续请求可以不等到一个请求成功响应继续发送其他请求，然而HTTP流水线已被证实很难在网络中实现（因为现有网络中有很多新老版本软件共存）。因此HTTP流水线被在多请求下表现稳定的HTTP/2帧形式取代")]),t._v(" "),e("h2",{attrs:{id:"http报文"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http报文"}},[t._v("#")]),t._v(" http报文")]),t._v(" "),e("p",[t._v("在http/1.1以及更早前，http协议的报文都是可读的，在http/2中，使用二进制结构帧来实现报文，但原理是一样的")]),t._v(" "),e("p",[t._v("使用二进制的优点：更加安全，传输更快(帧可以对报文头部压缩复用)；")]),t._v(" "),e("h3",{attrs:{id:"请求报文"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请求报文"}},[t._v("#")]),t._v(" 请求报文")]),t._v(" "),e("p",[t._v("1、method用来定义客户端行为，通过客户端的操作都是获取资源(GET)或发送html form表单(POST)；也会有一些其他操作如connect等")]),t._v(" "),e("p",[t._v("2、path通常为上下文中元素资源的url")]),t._v(" "),e("p",[t._v("3、协议版本号，hhtp/1.1或http/2")]),t._v(" "),e("p",[t._v("4、可选headers")]),t._v(" "),e("h3",{attrs:{id:"响应报文"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#响应报文"}},[t._v("#")]),t._v(" 响应报文")]),t._v(" "),e("p",[t._v("1、协议版本号，hhtp/1.1或http/2")]),t._v(" "),e("p",[t._v("2、状态码，来告知请求执行成功或失败及相关原因")]),t._v(" "),e("p",[t._v("3、状态信息，状态码描述信息，可以由服务端自行设定")]),t._v(" "),e("p",[t._v("4、headers")]),t._v(" "),e("h3",{attrs:{id:"api"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#api"}},[t._v("#")]),t._v(" api")]),t._v(" "),e("p",[t._v("基于http最常用的api是XMLHttpRequest；可以用来在userAgent与服务器之间交换数据，现代的fetch api提供了相同功能，并具有更强大和灵活的功能集")]),t._v(" "),e("p",[t._v("另一种api，即服务器发送事件，是一种单项服务，允许服务器使用http作为传输机制向客户端发送事件，使用EventSource接口在客户端打开连接并建立事件句柄，客户端浏览器将自动将到达http流的消息转换为适当的event对象，并传递给专门处理这类事件的句柄，如果这个句柄没有建立，就会交给onmessage事件处理程序处理")])])}),[],!1,null,null,null);a.default=v.exports}}]);
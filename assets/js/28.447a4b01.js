(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{456:function(a,t,e){"use strict";e.r(t);var s=e(65),r=Object(s.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("p",[a._v("通过复用以前获取的资源，可以显著提高网站和应用程序性能；web缓存减少了等待时间和网络流量，可以显著减少显示资源所需时间")]),a._v(" "),e("p",[a._v("当web缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去服务器上重新下载。")]),a._v(" "),e("p",[a._v("优点：缓解服务器压力，提升并发；提升性能（获取资源耗时更少）")]),a._v(" "),e("p",[a._v("缓存的核心是不能缓存过期的资源（要监测到变更），也是缓存最核心的问题")]),a._v(" "),e("h2",{attrs:{id:"缓存类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存类型"}},[a._v("#")]),a._v(" 缓存类型")]),a._v(" "),e("p",[a._v("可以大致分为私有缓存和共享缓存；共享缓存可以被多个用户使用，私有缓存只能用于单个用户。")]),a._v(" "),e("p",[a._v("主要的缓存方式有：浏览器缓存、代理缓存及部署在服务器上的缓存方式(网关缓存、CDN、反向代理缓存、负载均衡)")]),a._v(" "),e("p",[a._v("(私有)浏览器缓存：浏览器缓存拥有用户通过http下载的所有文档，这些缓存用以提供如向前/向后导航、保存网页、查看源码等，可以避免向服务器发起多余的请求。同样可以用来做离线应用")]),a._v(" "),e("p",[a._v("(共享)代理缓存: 例如ISP或架设一个web代理来作为本地网络基础的一个部分提供给用户，这样热门的资源就会被重复使用")]),a._v(" "),e("h2",{attrs:{id:"缓存操作的目标"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存操作的目标"}},[a._v("#")]),a._v(" 缓存操作的目标")]),a._v(" "),e("p",[a._v("http缓存只能存储GET响应，对其他类型的响应无法缓存")]),a._v(" "),e("h2",{attrs:{id:"cache-control头"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cache-control头"}},[a._v("#")]),a._v(" Cache-Control头")]),a._v(" "),e("p",[a._v("http/1.1定义的cache-control头用来区分对缓存机制的支持情况，请求头和响应头都支持这个属性，通过设置不同值来定义缓存策略（可以组合多个属性）")]),a._v(" "),e("p",[a._v("1、no-store不缓存任何内容，每次请求从服务器获取最新资源")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Cache-Control: no-store\n")])])]),e("p",[a._v("2、no-cache缓存但重新验证，每次请求都会发到服务器，服务器验证请求缓存是否过期，若未过期使用本地缓存拷贝")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Cache-Control: no-cache\n")])])]),e("p",[a._v("3、public可以被任何人缓存（如中间代理、cdn等）; private则是浏览器私有缓存")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Cache-Control: public\nCache-Control: private\n")])])]),e("p",[a._v("4、max-age过期机制，表示资源能够被缓存的最大时间，相对expires而言，max-age是距离请求发起的时间秒数（expires则是过期日期）。通常可以手动设置（一般是后台设置）一定的时长以保证资源缓存，如图片、js、css、数据")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Cache-Control: max-age=31536000\n")])])]),e("p",[a._v("5、must-revalidate验证方式，缓存必须先校验资源状态，已过期的缓存将不被使用")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Cache-Control: must-revalidate\n")])])]),e("h2",{attrs:{id:"pragma头"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pragma头"}},[a._v("#")]),a._v(" Pragma头")]),a._v(" "),e("p",[a._v("http/1.0标准中定了Pragma头，请求中包含Pragma等同于在头部定义Cache-Control: no-cache；但在响应头中没有这个属性，通常用来向后兼容基于http/1.0的客户端")]),a._v(" "),e("h2",{attrs:{id:"缓存过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存过程"}},[a._v("#")]),a._v(" 缓存过程")]),a._v(" "),e("p",[a._v("理论上，当一个资源被缓存存储后，可以被永久的存在在缓存中，但缓存的空间是有限的，所以缓存会定期将一些副本删除，这个过程叫缓存驱逐。")]),a._v(" "),e("p",[a._v("同时，当服务器上的资源更新，缓存中的资源也应该被更新，由于http协议是基于C/S模式的协议（client/server），服务器更新一个资源时不可能直接通知客户端更新缓存，所以双方必须为缓存的资源约定一个过期时间作为驱逐算法的依据；")]),a._v(" "),e("p",[a._v("缓存失效时间：比如Cache-control: max-age=N的头，相应的缓存的寿命就是N。如果请求头不包含这个属性，通过会根据expires属性，比较expires的值和头里面Date属性值来判断缓存是否有效；如果max-age和expires属性都没有，则会找请求头信息中的Last-Modified（还有ETags，但没有缓存失效时间，强制缓存验证），如果有，缓存失效时间就等于头信息中的Date值减去Last-Modified的值除以10")]),a._v(" "),e("h2",{attrs:{id:"缓存验证"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存验证"}},[a._v("#")]),a._v(" 缓存验证")]),a._v(" "),e("p",[a._v("只有在服务器返回强校验器或者弱校验器时才会进行缓存验证（即响应头包含ETags或Last-Modified）")]),a._v(" "),e("p",[a._v("当缓存的文档过期后，需要从服务器重新获取资源；触发缓存认证有以下行为")]),a._v(" "),e("p",[a._v("1、用户刷新页面")]),a._v(" "),e("p",[a._v("2、缓存的响应头包含Cache-control: must-revalidate")]),a._v(" "),e("p",[a._v("3、浏览器偏好设置里设置Advanced->Cache")]),a._v(" "),e("h3",{attrs:{id:"缓存验证校验器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存验证校验器"}},[a._v("#")]),a._v(" 缓存验证校验器")]),a._v(" "),e("p",[a._v("ETags(强校验器)：如果请求的响应头中包含ETags，客户端可以在后续的请求头中带上If-None-Match头来验证缓存")]),a._v(" "),e("p",[a._v("Last-Modified（弱校验器）：Last-Modified响应头可以作为一种弱校验器。说它弱是因为它只能精确到一秒。如果响应头里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。")]),a._v(" "),e("p",[a._v("当向服务器发起缓存验证的请求时，服务端会返回200 ok代表反正正常结果或者304 Not Modified(不返回body)表示可以使用本地缓存文件，通过304的响应头也可以同时更新缓存文档的过期时间")]),a._v(" "),e("h2",{attrs:{id:"改进资源"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#改进资源"}},[a._v("#")]),a._v(" 改进资源")]),a._v(" "),e("p",[a._v("我们使用缓存的资源越多，网站响应能力和性能就会约好，为了优化缓存，过期时间设置尽量长是一种很好的策略）；但对于一些一旦更新需要立即更新的资源，特指网页引入的一些js/css，更新就会很困难")]),a._v(" "),e("p",[a._v("web开发者发明了一种版本号的方案，带上版本号的资源会被缓存很久(一年甚至更长)，但如果资源需要变更，只需要修改版本号即可（可以通过自动化构建来更新资源版本号）；这种办法还有一个好处，可以避免多个文件缓存更新引发的依赖问题，避免这种不一致性是非常重要的")]),a._v(" "),e("h2",{attrs:{id:"vary响应头"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vary响应头"}},[a._v("#")]),a._v(" Vary响应头")]),a._v(" "),e("p",[a._v("Vary http响应头决定了对于后续的请求头，如何判断是请求一个新资源还是使用缓存文件")]),a._v(" "),e("p",[a._v("当服务器收到一个请求，只有当前请求缓存的请求头与缓存的响应头的Vary都匹配时，才能使用缓存响应")]),a._v(" "),e("p",[a._v("使用Vary头部有利于内容服务的动态多样性")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Vary: User-Agent\n")])])]),e("p",[a._v("因为移动版和桌面的客户端的请求头中的User-Agent不同， 缓存服务器不会错误地把移动端的内容输出到桌面端到用户。")])])}),[],!1,null,null,null);t.default=r.exports}}]);